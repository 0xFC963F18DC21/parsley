Theorem 1; All combinators either fail or result in exactly one item pushed onto the stack after complete execution

Note: if parsers fail, then the failure is dependant on order of appearance, which is preserved by these laws
      as pure parsers cannot fail and only pure parsers move position. Therefore we need only consider non-failing
      cases.
Note: As Push and Apply only use the operational stack (there is no jumping to be considered) we need only consider that
      stack.
Assumption: Assume that the functions used are pure functions. Impure functions may violate these laws. This is fine
            since the user's responsibility is to mark the parser as unsafe which disables optimisations based on
            laws that will become violated.

identity: pure id <*> v

{xs}
Push id
{id:xs}
V
{x:id:xs} - By Theorem 1
Apply
{id(x):xs}
{x:xs}
=
{xs}
V
{x:xs} - By Theorem 1

homomorphism: pure f <*> pure x = pure (f x)

{xs}
Push f
{f:xs}
Push x
{x:f:xs}
Apply
{f(x):xs}
=
{xs}
Push f(x)
{f(x):xs}

interchange: u <*> pure y = pure ($y) <*> u
{xs}
U
{f:xs} - By Theorem 1
Pure y
{y:f:xs}
Apply
{f(y):xs}
=
{xs}
Push $y
{$y:xs}
U
{f:$y:xs} - By Theorem 1
Apply
{($y)(f):xs}
{f$y:xs}
{f(y):xs}

composition: pure (.) <*> u <*> v <*> w = u <*> (v <*> w)
{xs}
Push (.)
{(.):xs}
U
{f:(.):xs} - By Theorem 1
Apply
{(.)(f):xs}
{(f.):xs}
V
{g:(f.):xs} - By Theorem 1
Apply
{(f.)(g):xs}
{(f.g):xs}
W
{x:(f.g):xs} - By Theorem 1
Apply
{(f.g)(x):xs}
{f(g(x)):xs}
=
{xs}
U
{f:xs} - By Theorem 1
V
{g:f:xs} - By Theorem 1
W
{x:g:f:xs} - By Theorem 1
Apply
{g(x):f:xs}
Apply
{f(g(x)):xs}

fmap: pure f <*> x = (fmap f) x
{xs}
Push f
{f:xs}
X
{x:f:xs} - By Theorem 1
Apply
{f(x):xs}
=
{xs}
X
{x:xs} - By Theorem 1
Perform f
{f(x):xs}